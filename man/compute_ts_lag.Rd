% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_ts_lag.R
\name{compute_ts_lag}
\alias{compute_ts_lag}
\title{Compute a Lagged Version of a Time Series Based on Date Ranges}
\usage{
compute_ts_lag(column, date_id, lag, max_lag, na.rm = TRUE)
}
\arguments{
\item{column}{A numeric vector representing the time series values that need to be lagged.}

\item{date_id}{A Date or POSIXct vector representing the dates corresponding to \code{column}.}

\item{lag}{A period (such as \code{months(3)}) representing the lower bound of the lag window.}

\item{max_lag}{A period representing the upper bound of the lag window. Must be greater than or equal to \code{lag}.}

\item{na.rm}{Logical; if \code{TRUE}, \code{NA} values in the \code{column} are removed before computation.}
}
\value{
A numeric vector with the same length as \code{column}, containing the lagged values.
If no matching dates are found within the lag window, \code{NA} is returned for that position.
}
\description{
This function computes a lagged version of a time series column based on a flexible date range.
The lag is defined by lower and upper date bounds rather than by a fixed number of observations.
}
\details{
The function works by creating a flexible date range for each date in \code{date_id}, defined by adding the \code{lag} and \code{max_lag} periods to the original date.
It then finds the closest matching date within this range and returns the corresponding value from \code{column}.
If there are multiple matches, the function selects the value from the closest date.
}
\examples{
data <- data.frame(
date = seq.Date(from = as.Date("2020-01-01"), by = "month", length.out = 10),
permno = rep(1:5, each = 10),
size = runif(10, 50, 100),
bm = runif(10, 0.1, 1.5)
)
data |> dplyr::group_by(permno) |>
  dplyr::mutate(across(c(size, bm), \(x) compute_ts_lag(x, date, months(3), months(6), na.rm = TRUE)))

}
