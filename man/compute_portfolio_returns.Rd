% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_portfolio_returns.R
\name{compute_portfolio_returns}
\alias{compute_portfolio_returns}
\title{Compute Portfolio Returns}
\usage{
compute_portfolio_returns(
  sorting_data,
  sorting_variables,
  sorting_method,
  rebalancing_frequency = "monthly",
  n_portfolios = NULL,
  percentiles = NULL,
  breakpoint_exchanges = NULL
)
}
\arguments{
\item{sorting_data}{A data frame containing the dataset for portfolio assignment and return computation.
It must contain columns for the sorting variables, \code{mktcap_lag}, and \code{ret_excess}.}

\item{sorting_variables}{A character vector specifying the column names in \code{sorting_data} to be used
for sorting and determining portfolio assignments. For univariate sorts, provide a single variable.
For bivariate sorts, provide two variables.}

\item{sorting_method}{A string specifying the sorting method to be used. Possible values are:
\itemize{
\item \code{"univariate"}: For a single sorting variable.
\item \code{"bivariate-dependent"}: For two sorting variables, where the second sort is dependent on the first.
\item \code{"bivariate-independent"}: For two independent sorting variables.
}}

\item{rebalancing_frequency}{A string specifying the frequency of rebalancing. Default is \code{"monthly"}.
Other supported value is \code{"annual"}.}

\item{n_portfolios}{An optional numeric vector specifying the number of portfolios to create for each
sorting variable. For univariate sorts, provide a single number. For bivariate sorts, provide two numbers.
Must match the length of \code{sorting_variables}.}

\item{percentiles}{An optional list of numeric vectors specifying the percentiles for determining the
breakpoints of the portfolios. This parameter is mutually exclusive with \code{n_portfolios}. The length of
the list must match the length of \code{sorting_variables}.}

\item{breakpoint_exchanges}{An optional character vector specifying exchange names to filter the data
before computing breakpoints and assigning portfolios. Exchanges must be stored in a column named
\code{exchange} in \code{sorting_data}. If \code{NULL}, no filtering is applied.}
}
\value{
A data frame with computed portfolio returns, containing the following columns:
\itemize{
\item \code{portfolio}: The portfolio identifier.
\item \code{date}: The date of the portfolio return.
\item \code{ret_excess_vw}: The value-weighted excess return of the portfolio.
\item \code{ret_excess_ew}: The equal-weighted excess return of the portfolio.
}
}
\description{
This function computes portfolio returns based on specified sorting variables and sorting methods.
The portfolios can be rebalanced at a specified frequency, such as monthly or annually. The function
supports univariate and bivariate sorts and can handle both dependent and independent sorting methods.
}
\details{
The function checks for consistency in the provided arguments. For univariate sorts, a single sorting
variable and a corresponding number of portfolios must be provided. For bivariate sorts, two sorting
variables and two corresponding numbers of portfolios (or percentiles) are required. The sorting method
determines how portfolios are assigned and returns are computed. The function handles missing and extreme
values appropriately based on the specified sorting method and rebalancing frequency.
}
\note{
Ensure that the \code{sorting_data} contains all the required columns: the specified sorting variables,
\code{mktcap_lag}, and \code{ret_excess}. The function will stop and throw an error if any required columns are missing.
}
\examples{
# Univariate sorting with monthly rebalancing
data <- data.frame(
  permno = 1:100,
  date = rep(seq.Date(from = as.Date("2020-01-01"), by = "month", length.out = 100), each = 10),
  mktcap_lag = runif(100, 100, 1000),
  ret_excess = rnorm(100),
  size = runif(100, 50, 150)
)
compute_portfolio_returns(data, sorting_variables = "size", sorting_method = "univariate", n_portfolios = 5)

# Bivariate dependent sorting with annual rebalancing
compute_portfolio_returns(data, sorting_variables = c("size", "mktcap_lag"), sorting_method = "bivariate-dependent", n_portfolios = c(3, 3), rebalancing_frequency = "annual")

}
